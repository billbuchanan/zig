# Zig cryptography
Demo applications are [here](https://asecuritysite.com/zig).

## Hashing

* Zig hashing [here](https://github.com/billbuchanan/zig/blob/main/zig/src/hash.zig). Zig is a relatively new programming language and which is simple to use. In this case, we will use the crypto library to integrate with the hashing methods of SHA-2 (SHA-224, SHA-256, SHA-384 and SHA-512), Blake2b, Blake2s, MD5, SHA-1, SHA-3 (Keccak and SHA-3) and Blake3.
* Hash composition with Zig [here](https://github.com/billbuchanan/zig/blob/main/zig/src/hash_comp.zig). A hash composition involves two hash functions (H1 and H2), and where for an input of b, we get H1(H2(b)). The security level of the hash is the same as the weakest level of the hash. There are some hashing methods that use the Merkle–Damgård constructions, such as SHA-256, and these are vulnerable to length-extension attacks. With this H(x||e) can be computed without actually knowing x. The composition of two hashing methods is one way to defend against this attack. Note, that we do not need this approach when we use methods such as SHA-3, BLAKE2 and BLAKE3. In this case, we will do a double hash for SHA-256 (Sha256oSha256), SHA-384 (Sha384oSha384) and SHA-512 (Sha512oSha512). For example, SHA-256(SHA-256("Hello")) = 70bc18bef5ae66b72d1995f8db90a583a60d77b4066e4653f1cead613025861c
* Zig SHA-3 hashing [here]. NIST wanted a hashing method to address the issues related to SHA-2, and created the SHA-3 competition. This led to the Keccak method being adopted as the SHA-3 standard. But this led to Ethereum adopting Keccak, whilst NIST modified it for the SHA-3 standard. Along with this, the SHA-3 method had high levels for security and which slowed down the process. To overcome this the designers reduced the number of rounds involved to 12, and where we have the Kangeroo 12 hashing method. This gives hashing rates which can compete with Blake2. BLAKE2b improved its speed by reducing the number of rounds from 16 to 12 and where BLAKE2s went from 14 to 10 rounds, with respect to BLAKE. This page outines the range of hashing methods we can gain from SHA-3/Keccak. This includes KMAC, and which is a MAC method and thus requires a random key. In this case, we will implement SHA-3/Keccak with Zig.
* Zig TupleHash [here]. TupleHash produces a variable-length hash function for tuples of byte strings and preserves the semantics of each string. It uses SHA-3 as its base and is standardized in NIST SP 800–185. Overall, it can use a 128-bit and a 256-bit version. For most hashing methods, we would get: SHA-256("bob" || "alice") = SHA-256("bo" || "balice"), but for a TupleHash, SHA-256("bob" || "alice") != SHA-256("bo" || "balice").
* SHA-3 SHAKE and cSHAKE [here]. If you break SHA-3 away from its fixed length output you get an EXtendable Output Function (XOF). This now has the potential of producing an almost infinite sets of outputs, and where we could thus take a single byte and produce an output of a billion bytes, or even take a billion bytes of input and produce a single byte output. In essence, it is a state generator, and where with given inputs we can reach a well-defined state. We can expose the state to anyone, as they will not know the secrets that allow us to take us to the previous and the next state. With SHA-3, we can use SHAKE128 or SHAKE256 for variable length of hash, and where SHAKE128 gives us 128-bit security, and SHAKE256 gives 256-bit security. With cSHAKE, we can also add a context string to the hashing process, and which allows us to seperate hashes with a domain string. Again, we can have cSHAKE128 and cSHAKE256. In this case, we will implement SHAKE128, SHAKE256, cSHAKE128 and cSHAKE256 in Zig.
* Ascon-256, Ascon-XOF128 and Ascon-cXOF128 (SP800-232) [here]. Ascon was designed by Christoph Dobraunig, Maria Eichlseder, Florian Mendel and Martin Schläffer from Graz University of Technology, Infineon Technologies, and Radboud University [1, 2]. It is both a light-weight hashing and encryption method. Ascon uses a single lightweight permutation with a Sponge-based modes of operation and a SPN (substitution–permutation network) permutation. Overall it has an easy method of implementing within hardware (2.6 gate equivalents) and software. A 5-bit S-box (as used in Keccak’s S-box core) is used to enable a light weight approach and it has no known side-channel attacks. It can also achieve high throughputs such as throughputs of between 4.9 and 7.3 Gbps. It stores its current state with 320 bits. Overall, Ascon won the NIST competition for a light-weight cryptography standard and can implement both symmetric key and hashing functions. In this case, we will implement Ascon-256, Ascon-XOF (eXtendable-Output Functions) 128 and Ascon-cXOF (and where we add a customization string. These correspond to the NIST standard of SP800-232 [ here]. For XOF, we define a length for the output hash.

## ECC

* Zig ECC (Secp256k1, P256, P384, Edwards, Curve 25519 and Ristretto255) [here]. With ECC (Elliptic Curve Cryptography), we have six main elliptic curve groups: Secp256k1, P256, P384, Edwards, Curve 25519 and Ristretto255. Secp256k1 is used in Bitcoin and Ethereum, P256 is commonly used for ECDH communications, P384 gives enhanced security over P256, Edwards is used with Ed25519 signature signing, Curve 25519 is used with X25519 key exchange, and Ristretto255 is a curve which overcomes some of the issues related to Curve 25519. In this case, we will use Zig to display the base point of the curves (G) and then generate a random scalar (a), and then compute the point [a].G.

## MAC

* Zig MAC [here]. A Message Authentication Code (MAC) allows Bob and Alice to share a secret key, and then use this to sign the hash of a message. The most popular MAC method is HMAC (Hash-based MAC). With ZIg, the crypto library supports HMAC (SHA-256, SHA-1 and MD5), Poly1305, CMAC (Cipher MAC), Ghash, Polyval, AEGIS (Family of Authenticated Encryption Algorithms) and Siphash. With ZIg, the crypto library supports HMAC (SHA-256, SHA-1 and MD5), Poly1305 and Siphash. In this case, HMAC and Poly1305 will use a random 256-bit key, and Siphash, CMAC (AES-128), GHASH, AEGIS and Polyval will use a 128-bit key. SipHash was published by Jean-Philippe Aumasson and Daniel J. Bernstein in 2012 [1], and addressed some of the issues caused by DoS attacks against hashing methods. It is a key-based hashing function, and where we can use a secret key to produce a hashed valued which cannot be reversed.
* Zig Keccak Message Authentication Code (KMAC) [here]. The Keccak Message Authentication Code (KMAC) algorithm supports a variable length keyed hash function, and where Keccak is based on the SHA-3 hashing method. For this, we can use either KMAC-128 and KMAC-256. In this case, we will implement KMAC-128 and KMAC-256 using a user generated key of any size. If the key size is long enough, both KMAC-128 and KMAC-256 can achieve 256-bit security. Overall with KMAC, we can define the number of bytes for the MAC, and where we can have any size of key.
* Zig Aegis Message Authentication Code [here]. The AEGIS family of Authenticated Encryption with Associated Data (AEAD) algorithms [1] have been designed to integrate with the pipelines and vectorized AES instructions that are supported on many CPUs [here]. The cipher won the CAESAR (Competition for Authenticated Encryption: Security, Applicability, and Robustness) competition. The two main methods that are supported in Zig are AEGIS-128L (using a 128-bit key) and AEGIS-256 (using a 256-bit key). In this case, we will use the cipher for a CMAC (Cipher MAC), and integrate AEGIS-128LMac, Aegis128X2Mac, Aegis128X4Mac, Aegis256Mac, Aegis256X2Mac and Aegis256X4Mac. The X2 and X4 versions are faster version of the integration. Each of these methods produce a 256-bit tag, and are extremely fast. AEGIS-128LMac uses a 128-bit key and provides 128-bit security (and has better security over Ghash and Poly1305). Aegis256Mac uses a 256-bit key and provides 256-bit security. With AES accelleration, CMAC (Cipher-based MAC) methods are generally faster than HMAC (Hash-based MAC) methods.

## Schnorr signature

* Zig Schnorr signature with P256 [here] In this case, we will implement the Schnorr signature method. We will produce a random 32 byte (256-bit) private key (d) with the P256 curve, and where the public key (Q) is then used to check the signature. In this case, we will implement with Zig and the NIST P256 curve.
* Zig Schnorr signature with Edwards25519 [here] In this case, we will implement the Schnorr signature method. We will produce a random 32 byte (256-bit) private key (d) with the Edwards25519 curve, and where the public key (Q) is then used to check the signature. In this case, we will implement with Zig and the Edwards25519 curve.
* Zig Schnorr signature with Ristretto255 [here] In this case, we will implement the Schnorr signature method. We will produce a random 32 byte (256-bit) private key (d) with the Ristretto255 group, and where the public key (Q) is then used to check the signature. In this case, we will implement with Zig and the Ristretto255 group.
* Zig Schnorr signature with secp256k1 [here] In this case, we will implement the Schnorr signature method. We will produce a random 32 byte (256-bit) private key (d) with the secp256k1 curve, and where the public key (Q) is then used to check the signature. In this case, we will implement with Zig and the secp256k1 curve.
* Zig Schnorr signature with NIST P384 [here] In this case, we will implement the Schnorr signature method. We will produce a random 32 byte (256-bit) private key (d) with the P384 curve, and where the public key (Q) is then used to check the signature. In this case, we will implement with Zig and the P384 curve.

## Key exchange

* Zig X25519 key exchange [here] Elliptic Curve Diffie Hellman (ECDH) is used to create a shared key. In this we use the elliptic curve defined as Curve 25519 to generate points on the curve. Bob will generate a public key (B) and private key (b), as will Alice (A and a). They then exchange their public keys, and the shared key will then be a×b×G, and where G is the generator point on the elliptic curve. In this case, we will implement X25519 with Zig.

## PQC ML-KEM

* Zig ML-KEM-512 [here] NIST standardised Kyber with FIPS 203 (ML-KEM). KEM allows a shared secret to be passed using public key methods. In this case, Alice will generate her key pair of a public key (pk) and a private key (sk). She then passes her public key to Bob, and Bob creates a ciphertext (ct) with Alice's public key. He passes the ciphertext to Alice, who decapsulates it with her private key. This will reveal the key that Bob wants Alice to use. ML-KEM-512 has a security level of AES-128, ML-KEM-738 maps to AES-192, and ML-KEM-1024 maps to AES-256. NIST has standardised Kyber with ML-KEM (FIPS 203). We will implement ML-KEM 512 using Zig.
* Zig ML-KEM-768 [here] This implements ML-KEM 768 using Zig.
* Zig ML-KEM-1024 [here] This implements ML-KEM 1024 using Zig.
* Zig ML-KEM Hybrid (ML-KEM 768 with P256) [here] In order to integrate our existing key exchange methods (such as with P256 and X25519) and PQC methods (such as ML-KEM), we can create a hybrid method. In this case, we will use Zig to implement with MlKem768P256, and which is ML-KEM-768 with the P256 curve. We can also use ML-KEM-768 with the X25519, and ML-KEM-1024 with P384 curve.
* Zig ML-KEM Hybrid (ML-KEM 768 with X25519) [here] In order to integrate our existing key exchange methods (such as with P256 and X25519) and PQC methods (such as ML-KEM), we can create a hybrid method. In this case, we will use Zig to implement with MlKem1024X25519, and which is ML-KEM-768 with the X25519 curve. This allows us to keep compatability with the Diffie-Hellman key exchange method.
* Zig ML-KEM Hybrid (ML-KEM 1024 with P384) [here] In order to integrate our existing key exchange methods (such as with P256, P384 and X25519) and PQC methods (such as ML-KEM), we can create a hybrid method. In this case, we will use Zig to implement with MlKem1024P384, and which is ML-KEM 1024 with P384.

## PQC ML-DSA

* Zig ML-DSA-44 [here] Dilithium has now been standardized by NIST as FIPS 204 (ML-DSA). The three methods are ML-DSA-44 (128-bit security), ML-DSA-65 (192-bit security), and ML-DSA-87 (256-bit security). In this case, we will use ML-DSA-44 with Zig.
* Zig ML-DSA-65 [here] Dilithium has now been standardized by NIST as FIPS 204 (ML-DSA). The three methods are ML-DSA-44 (128-bit security), ML-DSA-65 (192-bit security), and ML-DSA-87 (256-bit security). In this case, we will use ML-DSA-65 with Zig.
* Zig ML-DSA-87 [here] Dilithium has now been standardized by NIST as FIPS 204 (ML-DSA). The three methods are ML-DSA-44 (128-bit security), ML-DSA-65 (192-bit security), and ML-DSA-87 (256-bit security). In this case, we will use ML-DSA-87 with Zig.

## Signatures

* Zig Ed25519 signature [here] With Ed25519 signing, we can create a signature (r,s) with a message and a private key. The signature can then be verified with the associated public key. Overall, Ed25519 produces a deterministic method, as opposed to ECDSA, which uses a nonce value to create a non-deterministic signature. It is thus easier to test Ed25519 signatures. It also has excellent performance levels and does not suffer from nonce reuse, which is found in ECDSA. In this case, we will implement it with the Zig programming language.
* Zig ECDSA signature [here] The ECDSA signature using elliptic curve cryptography, such as with the P256 curve. With this, we sign a message with a private key, and then verify the signature with the message and the associated public key. Overall, ECDSA has been adopted within many areas, such as with Bitcoin and Ethereum. In this case, we will use Zig and the P256 curve to produce an ECDSA signature (r,s).
* ECDSA: Revealing the private key, if nonce known (secp256k1) [here] With an ECDSA signature, we sign a message with a private key (priv) and prove the signature with the public key (pub). A random value (a nonce) is then used to randomize the signature. Each time we sign, we create a random nonce value and it will produce a different (but verifiable) signature. Overall the signer only has to reveal the elements of the signature and their public key, and not the nonce value. If the signer reveals just one nonce value by mistake, an intruder can discover the private key. In this case we will reveal the nonce value, and determine the private key (secp256k1).
* Pure Zig ECDSA signature [here] ECDSA has been around for over two decades and was first proposed in [1]. The ECDSA method significantly improved the performance of signing messages than the RSA-based DSA method. Its usage of elliptic curve methods speeded up the whole process and supported much smaller key sizes. Its crown and glory were being selected by Satoshi Nakamoto for his Bitcoin protocol, and then its adoption into Ethereum, and uses the secp256k1 curve.

## Authenticated Encryption with Associated Data (AEAD)

* Zig 128-bit AES GCM [here] With enhanced encryption methods, we can both authenticate the cipher and prove its integrity. This is known as Authenticated Encryption with Associated Data (AEAD). For this we provide additional data to authenticate the encryption process, and where we can identify where the ciphertext has been modified, and for it not to be decrypted. Once of the most widely used methods is GCM (Galois/Counter Mode), and which converts the AES block cipher into a stream cipher. We encrypt with a key and a nonce value and additional data (AD) into the ciphering process. This produces the ciphertext and a tag. To decrypt, we then need the key, the tag, nonce value and additional data values. We will implement in Zig with 128-bit AES GCM. This will use a nonce (salt/IV) value of 12 bytes long (96 bits), and generate a tag of 16 bytes (128 bits).
* Zig 256-bit AES GCM [here] We will implement in Zig with 256-bit AES GCM. This will use a nonce (salt/IV) value of 12 bytes long (96 bits), and generate a tag of 16 bytes (128 bits).
* Zig 256-bit ChaCha20/Poly1305 AEAD [here] With enhanced encryption methods, we can both authenticate the cipher and prove its integrity. This is known as Authenticated Encryption with Associated Data (AEAD). In this case, we will use Zig to implement 256-bit ChaCha20 AEAD.
* Zig 256-bit XChaCha20/Poly1305 AEAD [here] With enhanced encryption methods, we can both authenticate the cipher and prove its integrity. This is known as Authenticated Encryption with Associated Data (AEAD). In this case, we will use Zig to implement XChaCha20/Poly1305 AEAD. With ChaCha20, we have a 96-bit (12 bytes) nonce value. For some applications, this nonce value may be too small, and so XChaCha20 increases this to 192 bits (24 bytes).
* Zig 256-bit ChaCha12/Poly1305 AEAD [here] With enhanced encryption methods, we can both authenticate the cipher and prove its integrity. This is known as Authenticated Encryption with Associated Data (AEAD). In this case, we will use Zig to implement ChaCha12/Poly1305 AEAD, and which has 12 round instead of 20 rounds. It is thus faster than ChaCha20. Overall, ChaCha20 is seen as much better for security over AES 256-bit, and where ChaCha12 is still seen as at least as strong as AES 256-bit
* Zig 128-bit AES OCB AEAD [here] With enhanced encryption methods, we can both authenticate the cipher and prove its integrity. This is known as Authenticated Encryption with Associated Data (AEAD). AEAD can be implemented with AES-OCB (Offset Code Book). This mode - designed by Professor Phil Rogaway [1] - is highly parallelizable and is provably secure. Basically, it does a single pass of the cipher block, where other modes such as GCM require two passes. Without processor acceleration, OCB mode is normally around 20-40% faster than GCM as it has a fairly simple operation and requires a single pass for the encryption and authentication, while GCM uses AES-CTR to encrypt, and requires two passes). We can easily parallelise OCM mode (as with GCM, but the GHASH element adds some latency). With processor enhancements, GCM draws closer to OCB, but OCB still tends to be faster. OCB is generally good for speed and a simpler design, while GCM provides more safety. OCB is defined in [RFC 7253]. This implements 128-bit AES OCB with Zig.
* Zig 256-bit AES OCB AEAD [here] This implements 256-bit AES OCB with Zig.
* Zig Isap v2.0 AEAD [here] With enhanced encryption methods, we can both authenticate the cipher and prove its integrity using Authenticated Encryption with Associated Data (AEAD). Isap v2.0 [1] is a lightweight permutation-based method for AEAD, and is has been designed to provided strong protection against side-channel and fault attacks. It was originally a candidate for NIST’s LightWeight Cryptography (LWC) project (and where NIST eventually selected Ascon).
* AEGIS AEAD using Zig. AEGIS AEAD using Zig. The AEGIS family of Authenticated Encryption with Associated Data (AEAD) algorithms [1] supports two main methods of AEGIS-128L (using a 128-bit key) and AEGIS-256 (using a 256-bit key). In this case, we will use the cipher to encrypt plaintext and decrypt the ciphertext for AEGIS-128 and Aegis256. Each of these methods produces a 128-bit or 256-bit tag, and are extremely fast compared with most other AES-based methods. AEGIS-128L uses a 128-bit key and a 128-bit nonce value - and provides 128-bit security (and has better security over Ghash and Poly1305). AEGIS-256 uses a 256-bit key and a 256-bit nonce - and provides 256-bit security. With AES acceleration, AEGIS is generally faster than AES GCM. We can use X2 and X4 methods which are even faster than the base method (AEGIS-128LX2, AEGIS-128LX4, AEGIS-256X2 and AEGIS-256X4).
* Ascon Authenticated Encryption with Additional Data (AEAD) with Zig. Ascon Authenticated Encryption with Additional Data (AEAD) with Zig. Ascon [1, 2] was designed by Christoph Dobraunig, Maria Eichlseder, Florian Mendel and Martin Schläffer from Graz University of Technology, Infineon Technologies, and Radboud University. It is both a light-weight hashing and encryption method. Ascon uses a single lightweight permutation with a Sponge-based modes of operation and an SPN (substitution–permutation network) permutation. NIST has now standardized Ascon as SP 800-232. In this case, we will implement Ascon with AEAD (Authenticated Encryption with Additional Data), and use a random nonce value, and additional data.
* AES SIV with Zig. AES SIV with Zig. Deterministic AEAD provides authenticity without the need for a nonce or IV. The SIV (Synthetic Initialization Vector) mode calculates an IV based on the entire input. A single bit of change in the plaintext results in ciphertext cannot be differentiated from other ciphertext. SIV is defined in [RFC 5297].
* AES CCM with Zig. AES CCM with Zig. AES is a secret key encryption method, and does not provide authentication of the message. CCM can add to AES by providing an authentication and encrypt block cipher mode [CCM - Counter with CBC-MAC]]. It has two parameters: M which indicates the indicates the size of the integrity check value (ICV) and L which defines the size of the length field in octets. It you want just CBC-MAC, set the IV to zero.

## NaCl Box Encryption

* NaCl Box with Zig [here] The Box encryption method is just beautiful and uses the power of public key cryptography and symmetric key. With this, Bob sends Alice an encrypted message using her public key, and then she uses her private key to decrypt it. Bob can then sign the message with his private key, and Alice proves that Bob sent it using his public key. Basically, it uses hybrid encryption, and where a symmetric secret key encrypts the message, and is then encrypted with Alice's public key. She then decrypts this with her private key, and can decrypt the ciphertext.
 NaCl Sealed Box with Zig [here] With a Sealed Box, Bob does not identify himself, and thus creates an anonymous encrypted message. This uses X25519 to exchange the symmetric key, and uses Alice's public key. It will use symmetric key encryption with XSala20/Poly1305 to encrypt the data.
* NaCl Secret Box with Zig [here] With Nacl Secret Box we have a shared secret key to close a seal encrypted box, and use the same secret key to open it. This uses AEAD (Authenticated Encryption with Additional Data) such as with XSalsa20Poly1305.

## KDF

* Zig bcrypt [here] MD5 and SHA-1 produce a hash signature, but this can be attacked by rainbow tables. Bcrypt is a more powerful hash generator for passwords and uses salt to create a non-recurrent hash. It was designed by Niels Provos and David Mazières, and is based on the Blowfish cipher [1]. It is used as the default password hashing method for BSD and many other systems. Overall it uses a 128-bit salt value, which requires 22 Radix-64 characters. It can use a number of iterations, which will slow down any brute-force cracking of the hashed value. An example for a password of "password" is "$2b$01$Li08/tQ0NcB3FYP8iEDKEOpTy9rq2lWAcskwIXXlYeKhtgRq1E38W", and where "2b" identifies bcrypt, "01" identifies the log of the number of rounds.
* Zig scrypt [here] scrypt is a password-based key derivation function which produces a hash with a salt and iterations. The iteration count slows down the cracking and the salt makes pre-computation difficult. The main parameters are: passphrase (msg); salt (S); blocksize (r), parallelisation (p), and CPU/Memory cost parameter (n - a power of 2).
* Zig PBKDF2 [here] PBKDF2 (Password-Based Key Derivation Function 2) is defined in RFC 2898 and generates a salted hash. Often this is used to create an encryption key from a defined password, and where it is not possible to reverse the password from the hashed value. It is used in TrueCrypt to generate the key required to read the header information of the encrypted drive, and which stores the encryption keys. It is also used in wifi (WPA-2) to protect the password that the user uses to connect to the wireless access point.
* Zig Argon2 [here] With ZIg, we can use Argon2id to hash a password.
* Zig HKDF [here] HMAC Key Derivation function (HKDF) is used to derive an encryption key from initial key material (IKM). With HKDF we use a given hashing method to the bases of the function, such as with SHA-512. With this, HKDF creates a pseudorandom key (PRK) using an IKM and a salt value in order to produce an HMAC hash function (such as HMAC-SHA512). This PRK output is used to produce a key of the required length. Next the PRK output is used to produce a key of the required length. If we generate a 16-byte output (32 hex characters), we have a 128-bit key, and a 32-byte output (64 hex characters) will generate a 256-bit key. HKDF is used in TLS 1.3 for generating encryption keys [RFC 5869][ article]. In this case we use the IKM as the input keying material and a salt value. From this we compute the pseudo random key (PRK) with HMAC-Hash(salt, IKM) and the OKM (output keying material) with HKDF-Expand(PRK, info, L), and where L is the length, and info is additional information. The PRK is a fixed length hash, whereas the OKM can be used to create any length of a pseudo random value. In practice, though, we use HMAC-SHA512 not for password hashing, but for generating encryption keys based on a shared secret, such as within a Diffie-Hellman key exchange.

## RSA

* RSA Encryption with Zig [here] With RSA, we have the magic of public key cryptography, and where Bob can generate a key pair: a public key and a private key, and then send Alice his public key. If she wants to encrypt something for him, she encrypts it with his public key, and then the only key which can decrypt it is his private key. A truly wonderful concept, and it was Rivest, Shamir and Adleman who made it come alive with the RSA method. In RSA, we start by generating two prime numbers (p,q) and then calculate the modulus (N) of N=pq. It is this modulus (N) that provides the core of the security of RSA, and it must be difficult to determine the prime numbers for a given modulus value. Our prime numbers must thus be of a size that makes it difficult to factorize, and they must be randomly generated. In real-life, we would use RSA-2024 and which would involve the generation of two 1,024 random prime numbers, but in this case we will use RSA-512 (in order to reduce the time take to generate two 256-bit random prime numbers). The code is generated in Zig.
* RSA Encryption (Simple) with Zig [here] Simple RSA using 256-bit primes and 512-bit modulus values.

## Finite Fields

* Finite Fields with Zig [here] A Finite Field (FF) involves - or a Galois field - has a finite number of elements, and where we can perform multiplication, addition, subtraction and division on these elements. A common field is defined by a prime number and where we take (modp) of the operation. Overall, we can define a modulus (N) to define the finite space, and where we have values from 0 to N−1. The modulus can either be a prime number or can be a composite number (and which is made up from the multiplication of a number of prime numbers).
* Non-Interactive ZKP (NI-ZKP) using secp256k1 with Fiat Shamir Heuristic with Zig (using Finite Field Maths) [here] We can use the Fiat-Shamir heuristic to prove that Peggy knows a secret x. She will send [x]G] to Victor to register her secret. Peggy can then produce her own challenge and proof, without Victor sending anything to Peggy. This is a Non-interactive Zero Knowledge Proof (NI-ZKP). In this case, we will use the secp256k1 curve, and will use finite-field maths.

## Zero Knowledge Proof

* Non-Interactive ZKP (NI-ZKP) using Ristretto255 with Fiat Shamir Heuristic with Zig [here] We can use the Fiat-Shamir heuristic to prove that Peggy knows a secret x. She will send [x]G] to Victor to register her secret. Peggy can then produce her own challenge and proof, without Victor sending anything to Peggy. This is a Non-interactive Zero Knowledge Proof (NI-ZKP). In this case, we will use the Ristretto255 curve, and which is based on Curve 25519, but has an order equal to the lastest sub-order prime of Curve 25519.
* Non-Interactive ZKP (NI-ZKP) using secp256k1 with Fiat Shamir Heuristic with Zig [here] We can use the Fiat-Shamir heuristic to prove that Peggy knows a secret x. She will send [x]G] to Victor to register her secret. Peggy can then produce her own challenge and proof, without Victor sending anything to Peggy. This is a Non-interactive Zero Knowledge Proof (NI-ZKP). In this case, we will use the secp256k1 curve.
* Non-Interactive ZKP (NI-ZKP) using NIST P256 with Fiat Shamir Heuristic with Zig [here] We can use the Fiat-Shamir heuristic to prove that Peggy knows a secret x. She will send [x]G] to Victor to register her secret. Peggy can then produce her own challenge and proof, without Victor sending anything to Peggy. This is a Non-interactive Zero Knowledge Proof (NI-ZKP). In this case, we will use the NIST P256 curve.
* Non-Interactive ZKP (NI-ZKP) using NIST P384 with Fiat Shamir Heuristic with Zig [here] We can use the Fiat-Shamir heuristic to prove that Peggy knows a secret x. She will send [x]G] to Victor to register her secret. Peggy can then produce her own challenge and proof, without Victor sending anything to Peggy. This is a Non-interactive Zero Knowledge Proof (NI-ZKP). In this case, we will use the NIST P384 curve.
* Non-Interactive ZKP (NI-ZKP) using Edwards25519 with Fiat Shamir Heuristic with Zig [here] We can use the Fiat-Shamir heuristic to prove that Peggy knows a secret x. She will send [x]G] to Victor to register her secret. Peggy can then produce her own challenge and proof, without Victor sending anything to Peggy. This is a Non-interactive Zero Knowledge Proof (NI-ZKP). In this case, we will use the Edwards25519 curve, and which is based on Curve 25519.
* Non-Interactive ZKP (NI-ZKP) using secp256k1 with Discrete Log Equivalence with Zig [here] Let's say we have two base points on an elliptic curve (G and H), and then have two random values (k and x). If we have Y=[x]G and Z=[x]H, can we prove that Y and Z use the same scalar value (x)? For this, we then use G,Y,M,Z within a Chaum-Pedersen proof [1] to provide a zero-knowledge proof that logG(Y)==logH(Z). This is defined as DLEQ(Z/H == Y/G) - discrete log equality. With this we can prove that the same private key has been used for [x]G and [x]H. It outlines zero-knowledge proof of log equality to prove Peggy's password (Chaum-Pedersen proof) using Zig and with the secp256k1 curve.

## Verifiable Random Function (VRF)

* Verifiable Random Function using secp256k1 with Discrete Log Equivalence with Zig [here] A Verifiable Random Function (VRF) allows the owner of a private key the ability to create a hashed value of data, while anyone with the associated public key can prove the validity of the hash. Thus the onwer of the private key can produce H(x) from H(x)=fpriv(x), while someone with the public key can prove that H(x) is the hash of x. This is similar to the approach of keyed cryptography hashes, but uses public key encryption for the key operation. We will use the method coded by Google and defined in the appendix of [1]. We will implement with Zig and the secp256k1 curve.

## Hybrid Encryption

* Hybrid Public Key (ECIES) using secp256k1 with Zig [here] With ECIES (Elliptic Curve Integrated Encryption Scheme) we use the public key from Elliptic Curve Cryptography in order to derive a symmetric key. In this case we create a symmetric key from Elliptic Curve Cryptography, and then use this to encrypt with AES-GCM. We will use the secp256k1 curve (as used with Bitcoin and Ethereum) and Zig.
* Hybrid Public Key (ECIES) using Curve 25519 with Zig [here] With ECIES (Elliptic Curve Integrated Encryption Scheme) we use the public key from Elliptic Curve Cryptography in order to derive a symmetric key. In this case we create a symmetric key from Elliptic Curve Cryptography, and then use this to encrypt with AES-GCM. We will use the Curve 25519 curve and Zig.
* Hybrid Public Key (ECIES) using X25519 with Zig [here] With ECIES (Elliptic Curve Integrated Encryption Scheme) we use the public key from Elliptic Curve Cryptography in order to derive a symmetric key. In this case we create a symmetric key from Elliptic Curve Cryptography, and then use this to encrypt with AES-GCM. We will use X25519 and Zig.
* Hybrid Public Key (ECIES) using P256 with Zig [here] With ECIES (Elliptic Curve Integrated Encryption Scheme) we use the public key from Elliptic Curve Cryptography in order to derive a symmetric key. In this case we create a symmetric key from Elliptic Curve Cryptography, and then use this to encrypt with AES-GCM. We will use NIST P256 and Zig.
* Hybrid ML-KEM-512 with Zig [here] With Hybrid Encryption, Bob uses a random symmetric key to encrypt data and then encapsulates this key with Alice's public key. Alice then decapsulates the key with her private key, and then reveals the required symmetric. With this, she can then decrypt the ciphertext. In this case, we will use Kyber (ML-KEM) public key encryption and AES as the symmetric key method. Overall, ML-KEM uses the CRYSTALS-Kyber method [1], and which is approved by NIST for key encapsulation and public key encryption. We will implement with Zig and ML-KEM-512.
* Hybrid ML-KEM-768 with Zig [here] With Hybrid Encryption, Bob uses a random symmetric key to encrypt data and then encapsulates this key with Alice's public key. Alice then decapsulates the key with her private key, and then reveals the required symmetric. With this, she can then decrypt the ciphertext. In this case, we will use Kyber (ML-KEM) public key encryption and AES as the symmetric key method. Overall, ML-KEM uses the CRYSTALS-Kyber method [1], and which is approved by NIST for key encapsulation and public key encryption. We will implement with Zig and ML-KEM-768.
* Hybrid ML-KEM-1024 with Zig [here] With Hybrid Encryption, Bob uses a random symmetric key to encrypt data and then encapsulates this key with Alice's public key. Alice then decapsulates the key with her private key, and then reveals the required symmetric. With this, she can then decrypt the ciphertext. In this case, we will use Kyber (ML-KEM) public key encryption and AES as the symmetric key method. Overall, ML-KEM uses the CRYSTALS-Kyber method [1], and which is approved by NIST for key encapsulation and public key encryption. We will implement with Zig and ML-KEM-1024.

## Social Millionaire Problem

* Socialist Millionaire Problem (SMP) with Zig and NIT P256 [here] With the socialist millionaire problem (SMP) - aka as the Off-the-Record Messaging protocol - we need to show that two millionaires either have the same amount of money or not, and without revealing their own value. In this case we will use the method defined by Boudot et al [1]. In this case, we will implement with Zig and the NIST P256 curve.

## Zig Benchmark

* Zig Benchmark [here] Zig provides a compiled version of a benchmarking tools for cryptography. This page provides the results.

## Camellia

* Camellia with Zig [here] Like AES, Camellia has a block size of 128 bits (16 bytes), and can use 128-, 192-, and 256-bit encryption keys. It was created by Mitsubishi and NTT and has been approved by the ISO/IEC. Camellia is also efficient for both hardware and software implementations, and is part of the TLS stack. Camellia is a Feisitel cipher and uses 18 rounds for 128-bit keys or 24 rounds for 192/256-bit keys. It also uses four 8x8 S-boxes. These s-boxes have a similar structure to the ones used by AES. This means that its performance can be enhanced by using the x86 AES-NI instruction set. In this case, we will implement a single block of 16 bytes with Zig.

## Commutative encryption

* Commutative encryption with ChaCha20 and Zig [here] With commutative encryption, we can decrypt with the keys in any order. Normally we would encrypt with Bob's key and then encrypt with Alice's key, and then we must decrypt with Alice's key and then Bob's. In commutative encryption, we can decrypt in any order. While our symmetric key block ciphers cannot be made commutative, we can use stream ciphers, as they perform an EX-OR function. In this example we will use the ChaCha20 stream cipher and Zig, and encrypt with Bob's key, encrypt with Alice's key, and then decrypt with Bob's key and then Alice's key. The encryption and decryption process is conducted with an XOR of the stream within a key stream generated by the encryption key. We will also add-in a nonce value into the creation of the key stream.
* Commutative encryption with ChaCha20 and Zig (different nonces) [here] We will implement commutative encryption with ChaCha20, and with randomly generated keys and nonce values for both Bob and Alice.
* Commutative Encryption with SHAKE-128 and Zig [here] We will implement commutative encryption with XOR operations, and keys generated from Bob and Alice from SHAKE128.

## Random number generators

* Random number generation with Zig [here] Zig supports a wide range of random number generators, including Xoshiro256, Ascon, Isaac64, ChaCha, Pcg, Xoshiro128, Sfc64, RomuTrio, and SplitMix64. In this case, we will enter a seed value, and then generate the first two random values. Xoshisho256 is the default one, and uses a shift-register generators approach that were invented by George Marsaglia [1]. Ascon is a light-weight cipher and ChaCha is a stream cipher. Both of these ciphers can be used as random number generators. PCG (permuted congruential generator) [2] uses a linear congruential generator to define a state-transition function, and is generally a strong random number generator. RomuTrio is part of the Romu (rotate-multiply) random-number generator family [3], and are generally fast in generating a sequence of random numbers. They combine the linear operation of multiplication with the nonlinear operation of rotation. With SplitMix64 is weak from a cryptographic point-of-view, and is a fairly simple method. In this case, we will use a 64-bit seed to generate the random sequence, and display the first two values. ISAAC-64 is a 64-bit version of the ISAAC (Indirection, Shift, Accumulate, Add, and Count) [4] algorithm. It is a ISAAC-64 fast methods and generally for for random numbers for non-cryptographic applications. With ChaCha and Ascon, we need to pass a 32 byte seed value to the initialisation method, while the other ones need a 64-bit unsigned integer value.

## BLS Curves

This is not a real implementation, but just implements a few outline methods.

* BLS12-381 with Zig [here] Barreto-Lynn-Scott (BLS) [1] curves are pairing friendly. They can be used to implement Bilinear groups and which are a triplet of groups (G1, G2 and GT), so that we can implement a function e() such that e(g1x,g2y)=gTxy, and where gx is the generator of the group. This is known as a pairing function. The main curves used are BLS12-381, BLS12-446, BLS12-455, BLS12-638 and BLS24-477. With BLS12-381 we have a Weierstrass curve with 381-bit field, and which takes the format of y2=x3+ax+bmodp [ Theory].
* Aggregated BL12-381 Signatures and Zig [here] In this case, we will bring together more than one signature, and then combine these to create a single signature without increasing the overall size of the resultant signature, and then create an aggregated public key to verify the signature.
* Threshold BL12-381 Signatures and Zig [here] With the (t,n)-threshold Boneh-Lynn-Shacham signature [1] scheme we can generate n shares for a signature, of which we need t of them to come back to verify the signature. This uses the Shamir Share method, and where we can recover a secret key from t shares out of n. In this case we will use five shares, and require three shares to come back together to recreate the signature.
