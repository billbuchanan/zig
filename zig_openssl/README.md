# Zig and OpenSSL

Zig provides an excellent integration with C programs, and where we can use C header files to compile our Zig code, and then link-in with a static library. In this case, we will integrate with OpenSSL header files, and then link this with the libstatic.lib library. The advantage of using Zig is that it has improved robustness against memory security issues that we would find with C.

Demo applications are [here](https://asecuritysite.com/zig).

## Hashing

* OpenSSL Hashing and Zig [ here] Zig is a relatively new programming language and which is simple to use. One of its strengths is that it can integrate with existing C code. In this case, we will integrate with the OpenSSL library, and use the OpenSSL header file of evp.h to compile our and then integrate with the libcrypto.lib library. This will integrate MD5, SHA-1, SHA-2 (SHA-256 and SHA-512), Whirlpool. RIPEMD160, SHA-3-256, SHA-3-512, Blake2bs-256, Blake2bs-512, SHAKE-128, SHAKE-256 and SM3.

## Random prime

* OpenSSL Random Prime and Zig [ here] In cryptography, we often have integers which are much larger than our standard 32-bit or 64-bit integers. For this, OpenSSL uses the BIGNUM (BN) library. In this case, we will generate a random prime number using this library for a given number of bits, and convert it to a hexadecimal and integer format. We can also generate a safe prime of p=2q+1, and where q is also a prime number. In this case, we will integrate with Zig with OpenSSL using the libcrypto.lib static library. Note that a safe prime takes much longer to create.   Testing for a prime with OpenSSL and Zig [ here] The usage of prime numbers in cryptography is fundamental, and thus the ability to generate and test for prime numbers. In this case, we will call up the BN_is_prime_ex() function in OpenSSL from Zig, and determine if a value is a prime number or not. We will also use the BN_num_bytes() function to determine the number of bytes in the value. Overall, OpenSSL uses a Big Number (BN) approach to store large integer values.

## PCQ: ML-KEM and ML-DSA

* ML-KEM Key Pair generation with OpenSSL and Zig [ here] The latest NIST specification for PQC key encapsulation is defined as FIPS203, and includes ML-KEM-512 (128-bit security), ML-KEM-768 (192-bit security) and ML-KEM-1024 (256-bit security). It is based on CRYSTALS-Kyber. In this case, we will use OpenSSL to implement the key encapsulation. Initally, Alice will generate a key pair (pkAlice and skAlice) and sends Bob her public key (pkAlice). Bob will then generate a new key (bobKey). He will then encrypt the new key (bobKey) with Alice's public key (pkAlice), and sends the resultant ciphertext (cipherText) to Alice. Alice then decrypts the ciphertext (cipherText) with her private key (skAlice). She then gets aliceKey, and which will be the same as bobKey. In this case, we will integrate with OpenSSL and use Zig.
* ML-DSA Key pair generation with OpenSSL and Zig [ here] CRYSTALS Dilithium uses lattice-based Fiat-Shamir schemes, and produces one of the smallest signatures of all the post-quantum methods, and with relatively small public and private key sizes. The three main implements for the parameters used are: Dilithium 2, Dilithium 3 and Dilithium 5. Overall, Dilithium 2 is equivalent to a 128-bit signature, and is perhaps the starting point for an implementation. CRYSTALS Dilithium has now been standardized by NIST as FIPS 204 (ML-DSA), and defined as ML-DSA-44 (Dilithium 2), ML-DSA-65 (Dilithium 3), and ML-DSA-87 (Dilithium 5). In this case, we will implement with Zig and integrate with OpenSSL.
* SLH-DSA Key pair generation with OpenSSL and Zig [ here] SLH-DSA (Stateless Hash-Based Digital Signature Standard) is a quantum robust digital signature method, and is standardized in FIPS 205. The method is build on the SPHINCS+ stateless hashing method and was one of the finalists for the NIST standard for PQC (Post Quantum Cryptography). It was proposed by Bernstein et al. in 2015 and updated in [2]. SPHINCS+ 256 128-bit has a public key size of 32 bytes, a private key size of 64 bytes, and a signature of 17KB. It has been shown to operate at speeds of hundreds of hashes per second on a 4-core 3.5GHz processor. In this case we will implement using SHA-256. Other hashing methods are Haraka and SHAKE-256, for 128-bit, 192-bit and 256-bit versions. In this case we will use the OpenSSL 3.5 library, and implement with SHA-2 and SHAKE (based on SHA-3), and use Zig.

## KDF

* PBKDF2 with OpenSSL and Zig [ here] PBKDF2 (Password-Based Key Derivation Function 2) is a key derivation function, which takes an input string, salt, and a number of rounds, and then outputs a byte stream a given size. This is then typically used with AES encryption, in order to secure the data. A 256-bit key has 32 bytes, and a 128-bit key has 16 bytes. It also uses a hashing method to process the output, such as with HMAC-SHA256 and HMAC-SHA512. One of its important advantages is that the conversion can be slowed down using increasing the number of rounds for the hashing process. In this case, we will use Zig to integrate with OpenSSL, and generate a PBKDF2-HMAC-SHA256 result for a given password, salt value, iterations and byte count.
* scrypt with OpenSSL and Zig [ here] scrypt is a password-based key derivation function which produces a hash with a salt and iterations. The iteration count slows down the cracking and the salt makes pre-computation difficult. The main parameters are: passphrase (P); salt (S); Blocksize (r) and CPU/Memory cost parameter (N - a power of 2). The salt value needs to be 256 bits long. In this case, we will use Zig to interface with OpenSSL through the VP_PBE_scrypt() function. The main parameters are Cost factor (n), BlockSizeFactor (r) and ParallelizationFactor (p). For n, we have a power of 2, and for r we can fine tune the sequential memory read size (commonly set to 8).
* Argon2 with OpenSSL and Zig [ here] Argon2 was designed by Alex Biryukov, Daniel Dinu, and Dmitry Khovratovich, and is a key derivation function (KDF), where we can create hashed values of passwords, or create encryption keys based on a password. It was a winner of the Password Hashing Competition in July 2015, and is robust against GPU and side channel attacks. It was integrated into OpenSSL 3.2. Argon2d uses a data-dependent approach to memory access, and Argon2i uses a data-independent approach. Argon2id is a hybrid construction. In this case, we will generate an Argon2 hash with OpenSSL and Zig.

## MAC

* MAC (KECCAK Message Authentication Code), Poly1305 and SIPHASH with OpenSSL and Zig [ here] The Keccak Message Authentication Code (KMAC) algorithm supports a variable length keyed hash function, and where Keccak is based on the SHA-3 hashing method. For this, we can use either KMAC128 (128-bit security) and KMAC256 (256-bit security), and produce a MAC of 32 bytes (256 bits) or 64 bytes (512 bits). We can also add a customization string. In this case, we will implement with Zig and integrate with OpenSSL.
* HMAC with OpenSSL and Zig [ here] HMAC (hash-based message authentication code) supports the usage of a key to hash data. This key is kept secret between Bob and Alice, and can be used to authenticate both the data and that the sender still knows the secret. Overall HMAC can be used with a range of different hashing methods, such as MD5, SHA-1, SHA-256 (SHA-2) and SHA-3. In this case we will use OpenSSL to generate the HMAC value, and use a Zig program. Overall, the key can be of any size, and where we take a hash of it to generate the required key for the MAC process.
* CMAC with OpenSSL and Zig [ here] CMACs (Cipher-based message authentication codes) create message authentication codes (MACs) using a block cipher and a secret key. They differ from HMACs in that they use a symmetric key method for the MACs rather than a hashing method. When the recipient receives the CMAC field, they will also compute the same CMAC with the message and the secret key. If they are the same, the recipient knows that the message has not been changed and signed with the secret key. Typical CMAC methods are AES-128-CBC and AES-256-CBC. In this case, we will use Zig to interface with OpenSSL.
* GMAC with OpenSSL and Zig [ here] AES GCM produces an output stream cipher, and requires a MAC to make sure that the ciphertext has not been changed. For this we use GMAC. Overall, GCM (Galois Counter Mode) is an encryption method with authentication for symmetric key encryption. It is fast and allows for parallel processing. The GF(2128)) field is used (x128+x7+x2+x+1). An authentication tag is created by inputting the data into a GHASH function and encrypting the result. This function is GHASH(H,A,C)=Xm+n+1 and where H=Ek(0,128) is the Hash Key —and which all 128 bits of zero, A defines the authenticated data, C defines the ciphertext, m related to the number of blocks, and n the number of blocks in C (rounded up). and the variable Xi for i=0,…,m+n+1. In this case, we will use Zig to interface with OpenSSL, and generate a random key and a random 96-bit IV value.

## ECC

* Generating a key pair (ECC) and ECDSA signature with OpenSSL and Zig [ here] This page generates an ECC key pair using OpenSSL and Zig. This includes secp256k1 (as used in Bitcoin and Ethereum) and secp256r1 (NIST P-256). For a curve of y2=x3+a.x+b(modp), we have the parameters include of p, a and b. We also have the generator point (G), and the order (n). In this case, we will generate all of the elliptic curves in OpenSSL using Zig.
* Ed25519 signature with OpenSSL and Zig [ here] Curve 25519 is one of the most widely used ECC methods. It uses a curve of y2=x3+486662x2+x [ plot], and which is a Montgomery curve. The prime number used is 2255−19. Ed25510 - EdDSA (Edwards-curve Digital Signature Algorithm) - is a fast and efficient digital signature method, and is based on the Schnorr signature scheme. Two important curves that are implemented with EdDSA are Curve 25519 (X25519) and Curve 448 (Ed448). EdDSA has been standardized in [ RFC 8032]. With EdDSA, Alice generates a private key of sk and a public key of P=sk.G and where G is the base point of the curve.

## RSA

* RSA Key pair generation and signature with OpenSSL and Zig [ here] RSA is an asymmetric key method, and uses a public key and a private key. Overall, the keys are created from two random prime numbers (p and (q) and where we create a modulus (N=pq). We then find an encryption exponent (e) and a decryption exponent (d). The public key is then [e,N] and the private key is [d,N]. In this case, we will use OpenSSL with Zig to generate the key, and where n is the public modulus, rsa-factor1 is p, rsa-factor2 is q, and d is the decryption exponent. The value of the encryption exponent (e) is 65,537.
* RSA Optimal Asymmetric Encryption Padding (OAEP) using Zig and OpenSSL [ here] Optimal Asymmetric Encryption Padding (OAEP) allows for a message to be encrypted using RSA. It thus uses RSA encryption and integrates a padding scheme. It was defined by Bellare and Rogaway, and has been standardized in PKCS#v1.5 and RFC 2437 [here]. We use RSA-OAEP to pad the message, and then encrypt with C=Mpe(modn) and decrypt with Mp=Cd(modN) and where Mp is the padded message. The padding is added before the encryption process, and then stripped off after decryption

## ASN.1

* ASN.1: DER using OpenSSL and Zig [ here] We need ways to distribute our public keys, private keys and digital certificates in a portable format. One of the most common forms is Distinguished Encoding Rules (DER) encoding of ASN.1. Overall it is truly binary representation of the encoded data. For a signature we often have the form of (r,s), a public key (pk) and a message (M). To check the signature we take the message (M), r, s and pk and validate the signature. In this case we will read in a DER hex string, and then parse to discover the contents of the DER format.


